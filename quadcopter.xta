/* --- Generated by genom 2.99.30. Do not edit -------------------------- */



/* This UPPAAL-SMC sepcification is automatically generated. Mohammed Foughali (LAAS/MDH, May 2017) */


		


/* force broadcast channels to behave as sync ones */
	
bool s_mikrokopter:= false;

	
bool s_nhfc:= false;

	
bool s_maneuver:= false;


/* ports */


const int nports:= 7;
bool ports[nports]:= { false, false, false, false, false, false, false};


/* urgency */


urgent broadcast chan exe;

/* channels, variables and functions (mikrokopter) */
/* channels */

urgent broadcast chan recv_urg_mikrokopter, shuttimer_main_mikrokopter, begin_main_mikrokopter, inter_main_mikrokopter;
urgent broadcast chan recv_mikrokopter;	
broadcast chan end_spawn_comm_mikrokopter, end_spawn_main_mikrokopter;	
urgent broadcast chan go_main_mikrokopter;

/* constants & global variables */
bool shut_mikrokopter:= false;

bool sched_mikrokopter:= false;
bool lock_main_mikrokopter:= true;
bool finished_main_mikrokopter:= false;
bool tick_main_mikrokopter:= false;
bool lock_comm_mikrokopter:= true;
/* services IDs */
/* attributes, activities & functions */
const int start_mikrokopter:= 0;
const int servo_mikrokopter:= 1;
const int nserv_mikrokopter:= 2;
const int width_mikrokopter:= 2;
const int size_mikrokopter:= width_mikrokopter*2+1;
// the abort request is a negative "i" number that refers to interrupting the element whose index is i+size-1 
const int kill_mikrokopter:= -1*size_mikrokopter;

/* services with validate */

/* none (urgent reaction of CT with no request in the mbox) */
const int none_mikrokopter:= kill_mikrokopter -1;

/* status */
// this choice is deleberate to ease manipulating interruptions
const int RUN_mikrokopter:= 0;
const int WAIT_mikrokopter:= 1;
const int STOP_mikrokopter:= 2;
const int ETHER_mikrokopter:= 3; 
const int VOID_mikrokopter:= 4;

/* activities array */
/* structure */ 
typedef struct {int [-1,width_mikrokopter-1] name; int [1,2] inst; int [RUN_mikrokopter,VOID_mikrokopter] status;} cell_mikrokopter;
/* initialisation */
cell_mikrokopter tab_mikrokopter[size_mikrokopter] := { {start_mikrokopter,1,VOID_mikrokopter}, {start_mikrokopter,2,VOID_mikrokopter}, {servo_mikrokopter,1,VOID_mikrokopter}, {servo_mikrokopter,2,VOID_mikrokopter}, {-1,1,VOID_mikrokopter} }; 
int [none_mikrokopter,nserv_mikrokopter-1] req_mikrokopter:= kill_mikrokopter;


cell_mikrokopter turn_main_mikrokopter:={-1,1,VOID_mikrokopter};



/* mutual exclusion array */

const int length_mut_mikrokopter:= 11;
bool mutex_mikrokopter[length_mut_mikrokopter]:= {false, false, false, false, false, false, false, false, false, false, false};
/* functions */

/* abort and kill effect */
	
	
void interrupt_cntrl_mikrokopter (int[none_mikrokopter,-1] i, cell_mikrokopter &tab[size_mikrokopter], bool &shut) {
int[0,size_mikrokopter-1] j;
if (i==none_mikrokopter) {return;}
if (i!=kill_mikrokopter) {
            if (tab[i+size_mikrokopter-1].status<STOP_mikrokopter) {tab[i+size_mikrokopter-1].status += STOP_mikrokopter;}
						return;}
for (j:=0; j<size_mikrokopter-1; j++) {
                    if (tab[j].status<STOP_mikrokopter) {tab[j].status += STOP_mikrokopter;}}
shut := true;
}

/* clear and launch */
void launch_serv_mikrokopter (cell_mikrokopter &tab[size_mikrokopter]) {
int i,j;
bool launch:= true;
for (i:=0; i<size_mikrokopter-1; i++) {
            if (tab[i].status==ETHER_mikrokopter) {tab[i].status:=VOID_mikrokopter;}//final replies
}
for (i:=0; i<size_mikrokopter-1; i++) {
    if (tab[i].status==WAIT_mikrokopter) {		
        if (tab[i].name==servo_mikrokopter) {tab[i].status:=RUN_mikrokopter;}
        else {
   if (tab[i].name==start_mikrokopter) {
   for (j:= 0; (j<size_mikrokopter-1 && launch); j++) {
                if (j!=i && (tab[j].name == start_mikrokopter) && tab[j].status!=VOID_mikrokopter) {
                    launch:= false;}}
               if (launch) {tab[i].status:=RUN_mikrokopter;}
               else {launch:= true;}}
       }
}
}}                    
/* interrupt incompatible instances */
void manage_intterupt_mikrokopter (int[0,nserv_mikrokopter-1] s, int[0,size_mikrokopter-2] i, cell_mikrokopter &tab[size_mikrokopter]) {
int[0,size_mikrokopter-1] j;	
	if (s == start_mikrokopter) {
		for (j:= 0; j<size_mikrokopter-1; j++) {
		if (j != i && (tab[j].name == start_mikrokopter) && tab[j].status<2) {tab[j].status += 2;}}
				return;}
}

/* update status of terminated services */
void update_mikrokopter (bool &finished, int[0,size_mikrokopter-2] i, cell_mikrokopter &tab[size_mikrokopter]) {
if (finished) {finished:= false;
                tab[i].status:= ETHER_mikrokopter;}
}

/* signal the end of at least an activity */
bool sched_cntrl_mikrokopter (cell_mikrokopter tab[size_mikrokopter]) {
int[0,size_mikrokopter-1] i;
for (i:=0; i<size_mikrokopter-1; i++) {
                       if (tab[i].status == ETHER_mikrokopter) {return true;}}
return false;}

/* look for a slot and interrupt if necesary */
void slot_search_mikrokopter (int[0,width_mikrokopter-1] a, cell_mikrokopter &tab[size_mikrokopter]) {
int[0,size_mikrokopter-1] i:= 0;
while (tab[i].name != a) {i:= i+1;}
while (tab[i].name == a) {if (tab[i].status == VOID_mikrokopter)
                           {tab[i].status := WAIT_mikrokopter;
                            manage_intterupt_mikrokopter(a, i, tab);
                            return;}
                            i:= i+1;}
return;}

/* look for the next instance to execute */
int next_mikrokopter (int[0,size_mikrokopter-1] i, cell_mikrokopter tab[size_mikrokopter], int[0,size_mikrokopter-1] stop_point) {
while (i < stop_point) {
 if (tab[i].status == RUN_mikrokopter || tab[i].status == STOP_mikrokopter) {return i;}
 i:= i+1;}
return size_mikrokopter-1;}

/* shutdown */
bool off_signal_mikrokopter (cell_mikrokopter tab[size_mikrokopter]) {
int[0,size_mikrokopter-1] j;
for (j:= 0; j<size_mikrokopter-1; j++) {
    if (tab[j].status != VOID_mikrokopter && tab[j].status != ETHER_mikrokopter) {return false;}}
return true;}

	
/* determine whether it is the first execution of a permanent activity */
void update_lock_mikrokopter (bool shift, bool &lock) {
if (!shift) {lock:= true;}
}
/* channels, variables and functions (pom) */
/* channels */

urgent broadcast chan recv_urg_pom, shuttimer_io_pom, shuttimer_filter_pom;
urgent broadcast chan recv_pom;	
broadcast chan end_spawn_filter_pom, end_spawn_io_pom;	
urgent broadcast chan go_io_pom, go_filter_pom;

/* constants & global variables */
bool shut_pom:= false;
bool lock_io_pom:= true;
bool tick_io_pom:= false;
bool lock_filter_pom:= true;
bool tick_filter_pom:= false;
/* services IDs */
/* attributes, activities & functions */
const int nserv_pom:= 0;
const int kill_pom:=-1;

int [kill_pom,nserv_pom-1] req_pom:= kill_pom;




/* mutual exclusion array */

const int length_mut_pom:= 4;
bool mutex_pom[length_mut_pom]:= {false, false, false, false};
/* functions */

	
/* determine whether it is the first execution of a permanent activity */
void update_lock_pom (bool shift, bool &lock) {
if (!shift) {lock:= true;}
}
/* channels, variables and functions (nhfc) */
/* channels */

urgent broadcast chan recv_urg_nhfc, shuttimer_main_nhfc, begin_main_nhfc, inter_main_nhfc;
urgent broadcast chan recv_nhfc;	
broadcast chan end_spawn_main_nhfc;	
urgent broadcast chan go_main_nhfc;

/* constants & global variables */
bool shut_nhfc:= false;

bool sched_nhfc:= false;
bool lock_main_nhfc:= true;
bool finished_main_nhfc:= false;
bool tick_main_nhfc:= false;
/* services IDs */
/* attributes, activities & functions */
const int servo_nhfc:= 0;
const int nserv_nhfc:= 1;
const int width_nhfc:= 1;
const int size_nhfc:= width_nhfc*2+1;
// the abort request is a negative "i" number that refers to interrupting the element whose index is i+size-1 
const int kill_nhfc:= -1*size_nhfc;

/* services with validate */

/* none (urgent reaction of CT with no request in the mbox) */
const int none_nhfc:= kill_nhfc -1;

/* status */
// this choice is deleberate to ease manipulating interruptions
const int RUN_nhfc:= 0;
const int WAIT_nhfc:= 1;
const int STOP_nhfc:= 2;
const int ETHER_nhfc:= 3; 
const int VOID_nhfc:= 4;

/* activities array */
/* structure */ 
typedef struct {int [-1,width_nhfc-1] name; int [1,2] inst; int [RUN_nhfc,VOID_nhfc] status;} cell_nhfc;
/* initialisation */
cell_nhfc tab_nhfc[size_nhfc] := { {servo_nhfc,1,VOID_nhfc}, {servo_nhfc,2,VOID_nhfc}, {-1,1,VOID_nhfc} }; 
int [none_nhfc,nserv_nhfc-1] req_nhfc:= kill_nhfc;


cell_nhfc turn_main_nhfc:={-1,1,VOID_nhfc};


/* functions */

/* abort and kill effect */
	
	
void interrupt_cntrl_nhfc (int[none_nhfc,-1] i, cell_nhfc &tab[size_nhfc], bool &shut) {
int[0,size_nhfc-1] j;
if (i==none_nhfc) {return;}
if (i!=kill_nhfc) {
            if (tab[i+size_nhfc-1].status<STOP_nhfc) {tab[i+size_nhfc-1].status += STOP_nhfc;}
						return;}
for (j:=0; j<size_nhfc-1; j++) {
                    if (tab[j].status<STOP_nhfc) {tab[j].status += STOP_nhfc;}}
shut := true;
}

/* clear and launch */
void launch_serv_nhfc (cell_nhfc &tab[size_nhfc]) {
int i,j;
bool launch:= true;
for (i:=0; i<size_nhfc-1; i++) {
            if (tab[i].status==ETHER_nhfc) {tab[i].status:=VOID_nhfc;}//final replies
}
for (i:=0; i<size_nhfc-1; i++) {
    if (tab[i].status==WAIT_nhfc) {		
        if (tab[i].name==servo_nhfc) {tab[i].status:=RUN_nhfc;}
        else {}
}
}}                    
/* interrupt incompatible instances */
void manage_intterupt_nhfc (int[0,nserv_nhfc-1] s, int[0,size_nhfc-2] i, cell_nhfc &tab[size_nhfc]) {
int[0,size_nhfc-1] j;
}

/* update status of terminated services */
void update_nhfc (bool &finished, int[0,size_nhfc-2] i, cell_nhfc &tab[size_nhfc]) {
if (finished) {finished:= false;
                tab[i].status:= ETHER_nhfc;}
}

/* signal the end of at least an activity */
bool sched_cntrl_nhfc (cell_nhfc tab[size_nhfc]) {
int[0,size_nhfc-1] i;
for (i:=0; i<size_nhfc-1; i++) {
                       if (tab[i].status == ETHER_nhfc) {return true;}}
return false;}

/* look for a slot and interrupt if necesary */
void slot_search_nhfc (int[0,width_nhfc-1] a, cell_nhfc &tab[size_nhfc]) {
int[0,size_nhfc-1] i:= 0;
while (tab[i].name != a) {i:= i+1;}
while (tab[i].name == a) {if (tab[i].status == VOID_nhfc)
                           {tab[i].status := WAIT_nhfc;
                            manage_intterupt_nhfc(a, i, tab);
                            return;}
                            i:= i+1;}
return;}

/* look for the next instance to execute */
int next_nhfc (int[0,size_nhfc-1] i, cell_nhfc tab[size_nhfc], int[0,size_nhfc-1] stop_point) {
while (i < stop_point) {
 if (tab[i].status == RUN_nhfc || tab[i].status == STOP_nhfc) {return i;}
 i:= i+1;}
return size_nhfc-1;}

/* shutdown */
bool off_signal_nhfc (cell_nhfc tab[size_nhfc]) {
int[0,size_nhfc-1] j;
for (j:= 0; j<size_nhfc-1; j++) {
    if (tab[j].status != VOID_nhfc && tab[j].status != ETHER_nhfc) {return false;}}
return true;}

	
/* determine whether it is the first execution of a permanent activity */
void update_lock_nhfc (bool shift, bool &lock) {
if (!shift) {lock:= true;}
}
/* channels, variables and functions (maneuver) */
/* channels */

urgent broadcast chan recv_urg_maneuver, shuttimer_plan_maneuver, begin_plan_maneuver, inter_plan_maneuver, shuttimer_exec_maneuver;
urgent broadcast chan recv_maneuver;	
broadcast chan end_spawn_exec_maneuver, end_spawn_plan_maneuver;	
urgent broadcast chan go_exec_maneuver;

/* constants & global variables */
bool shut_maneuver:= false;

bool sched_maneuver:= false;
bool lock_plan_maneuver:= true;
bool finished_plan_maneuver:= false;
bool tick_plan_maneuver:= false;
bool lock_exec_maneuver:= true;
bool tick_exec_maneuver:= false;
/* services IDs */
/* attributes, activities & functions */
const int set_current_state_maneuver:= 0;
const int take_off_maneuver:= 1;
const int waypoint_maneuver:= 2;
const int wait_maneuver:= 3;
const int set_bounds_maneuver:= 4;
const int nserv_maneuver:= 5;
const int width_maneuver:= 4;
const int size_maneuver:= width_maneuver*2+1;
// the abort request is a negative "i" number that refers to interrupting the element whose index is i+size-1 
const int kill_maneuver:= -1*size_maneuver;

/* services with validate */

/* none (urgent reaction of CT with no request in the mbox) */
const int none_maneuver:= kill_maneuver -1;

/* status */
// this choice is deleberate to ease manipulating interruptions
const int RUN_maneuver:= 0;
const int WAIT_maneuver:= 1;
const int STOP_maneuver:= 2;
const int ETHER_maneuver:= 3; 
const int VOID_maneuver:= 4;

/* activities array */
/* structure */ 
typedef struct {int [-1,width_maneuver-1] name; int [1,2] inst; int [RUN_maneuver,VOID_maneuver] status;} cell_maneuver;
/* initialisation */
cell_maneuver tab_maneuver[size_maneuver] := { {set_current_state_maneuver,1,VOID_maneuver}, {set_current_state_maneuver,2,VOID_maneuver}, {take_off_maneuver,1,VOID_maneuver}, {take_off_maneuver,2,VOID_maneuver}, {waypoint_maneuver,1,VOID_maneuver}, {waypoint_maneuver,2,VOID_maneuver}, {wait_maneuver,1,VOID_maneuver}, {wait_maneuver,2,VOID_maneuver}, {-1,1,VOID_maneuver} }; 
int [none_maneuver,nserv_maneuver-1] req_maneuver:= kill_maneuver;


cell_maneuver turn_plan_maneuver:={-1,1,VOID_maneuver};



/* mutual exclusion array */

const int length_mut_maneuver:= 13;
bool mutex_maneuver[length_mut_maneuver]:= {false, false, false, false, false, false, false, false, false, false, false, false, false};
/* functions */

/* abort and kill effect */
	
	
void interrupt_cntrl_maneuver (int[none_maneuver,-1] i, cell_maneuver &tab[size_maneuver], bool &shut) {
int[0,size_maneuver-1] j;
if (i==none_maneuver) {return;}
if (i!=kill_maneuver) {
            if (tab[i+size_maneuver-1].status<STOP_maneuver) {tab[i+size_maneuver-1].status += STOP_maneuver;}
						return;}
for (j:=0; j<size_maneuver-1; j++) {
                    if (tab[j].status<STOP_maneuver) {tab[j].status += STOP_maneuver;}}
shut := true;
}

/* clear and launch */
void launch_serv_maneuver (cell_maneuver &tab[size_maneuver]) {
int i,j;
bool launch:= true;
for (i:=0; i<size_maneuver-1; i++) {
            if (tab[i].status==ETHER_maneuver) {tab[i].status:=VOID_maneuver;}//final replies
}
for (i:=0; i<size_maneuver-1; i++) {
    if (tab[i].status==WAIT_maneuver) {		
        if (tab[i].name==set_current_state_maneuver || tab[i].name==wait_maneuver) {tab[i].status:=RUN_maneuver;}
        else {
   if (tab[i].name==take_off_maneuver) {
   for (j:= 0; (j<size_maneuver-1 && launch); j++) {
                if (j!=i && (tab[j].name == take_off_maneuver) && tab[j].status!=VOID_maneuver) {
                    launch:= false;}}
               if (launch) {tab[i].status:=RUN_maneuver;}
               else {launch:= true;}}
       
	
   else
   if (tab[i].name==waypoint_maneuver) {
   for (j:= 0; (j<size_maneuver-1 && launch); j++) {
                if (j!=i && (tab[j].name == waypoint_maneuver) && tab[j].status!=VOID_maneuver) {
                    launch:= false;}}
               if (launch) {tab[i].status:=RUN_maneuver;}
               else {launch:= true;}}
       }
}
}}                    
/* interrupt incompatible instances */
void manage_intterupt_maneuver (int[0,nserv_maneuver-1] s, int[0,size_maneuver-2] i, cell_maneuver &tab[size_maneuver]) {
int[0,size_maneuver-1] j;	
	if (s == take_off_maneuver) {
		for (j:= 0; j<size_maneuver-1; j++) {
		if (j != i && (tab[j].name == take_off_maneuver) && tab[j].status<2) {tab[j].status += 2;}}
				return;}	
	if (s == waypoint_maneuver) {
		for (j:= 0; j<size_maneuver-1; j++) {
		if (j != i && (tab[j].name == waypoint_maneuver) && tab[j].status<2) {tab[j].status += 2;}}
				return;}
}

/* update status of terminated services */
void update_maneuver (bool &finished, int[0,size_maneuver-2] i, cell_maneuver &tab[size_maneuver]) {
if (finished) {finished:= false;
                tab[i].status:= ETHER_maneuver;}
}

/* signal the end of at least an activity */
bool sched_cntrl_maneuver (cell_maneuver tab[size_maneuver]) {
int[0,size_maneuver-1] i;
for (i:=0; i<size_maneuver-1; i++) {
                       if (tab[i].status == ETHER_maneuver) {return true;}}
return false;}

/* look for a slot and interrupt if necesary */
void slot_search_maneuver (int[0,width_maneuver-1] a, cell_maneuver &tab[size_maneuver]) {
int[0,size_maneuver-1] i:= 0;
while (tab[i].name != a) {i:= i+1;}
while (tab[i].name == a) {if (tab[i].status == VOID_maneuver)
                           {tab[i].status := WAIT_maneuver;
                            manage_intterupt_maneuver(a, i, tab);
                            return;}
                            i:= i+1;}
return;}

/* look for the next instance to execute */
int next_maneuver (int[0,size_maneuver-1] i, cell_maneuver tab[size_maneuver], int[0,size_maneuver-1] stop_point) {
while (i < stop_point) {
 if (tab[i].status == RUN_maneuver || tab[i].status == STOP_maneuver) {return i;}
 i:= i+1;}
return size_maneuver-1;}

/* shutdown */
bool off_signal_maneuver (cell_maneuver tab[size_maneuver]) {
int[0,size_maneuver-1] j;
for (j:= 0; j<size_maneuver-1; j++) {
    if (tab[j].status != VOID_maneuver && tab[j].status != ETHER_maneuver) {return false;}}
return true;}

	
/* determine whether it is the first execution of a permanent activity */
void update_lock_maneuver (bool shift, bool &lock) {
if (!shift) {lock:= true;}
}
/* channels, variables and functions (optitrack) */
/* channels */

urgent broadcast chan recv_urg_optitrack, shuttimer_publish_optitrack;
urgent broadcast chan recv_optitrack;	
broadcast chan end_spawn_publish_optitrack;	
urgent broadcast chan go_publish_optitrack;

/* constants & global variables */
bool shut_optitrack:= false;
bool lock_publish_optitrack:= true;
bool tick_publish_optitrack:= false;
/* services IDs */
/* attributes, activities & functions */
const int nserv_optitrack:= 0;
const int kill_optitrack:=-1;

int [kill_optitrack,nserv_optitrack-1] req_optitrack:= kill_optitrack;



/* functions */

	
/* determine whether it is the first execution of a permanent activity */
void update_lock_optitrack (bool shift, bool &lock) {
if (!shift) {lock:= true;}
}

process control_mikrokopter(bool &s_mikrokopter, urgent broadcast chan &recv_mikrokopter, urgent broadcast chan &exe, bool &shut_mikrokopter, urgent broadcast chan &recv_urg_mikrokopter, cell_mikrokopter &tab_mikrokopter[size_mikrokopter], bool &sched_mikrokopter, broadcast chan &end_spawn_comm_mikrokopter, int[none_mikrokopter,nserv_mikrokopter-1] &req_mikrokopter, bool &mutex_mikrokopter[length_mut_mikrokopter]) {

clock x;
state
    shutdown { ; 10000 },
    receive { ; 10000 },
    unspawned { ; 10000 },
    decode,
    manage,
    wait { ; 10000 },
    finish;
commit
    decode;
urgent
    manage,
    finish;
init
    unspawned;
trans
    unspawned -> receive { sync end_spawn_comm_mikrokopter?; assign s_mikrokopter:= true; },
    receive -> decode { guard sched_mikrokopter; sync recv_urg_mikrokopter?; assign sched_mikrokopter:= false, s_mikrokopter:= false; },
    decode -> finish { guard req_mikrokopter < 0; assign interrupt_cntrl_mikrokopter(req_mikrokopter,tab_mikrokopter,shut_mikrokopter); },
    manage -> finish { assign slot_search_mikrokopter (req_mikrokopter, tab_mikrokopter); },
    decode -> manage { guard req_mikrokopter >=start_mikrokopter  && req_mikrokopter <=servo_mikrokopter; },
    finish -> receive { guard !shut_mikrokopter; assign launch_serv_mikrokopter(tab_mikrokopter), s_mikrokopter:= true; },
    receive -> decode { guard !sched_mikrokopter; sync recv_mikrokopter?; assign s_mikrokopter:= false; },
    finish -> wait { guard shut_mikrokopter; },
    wait -> shutdown { guard off_signal_mikrokopter(tab_mikrokopter); sync exe!; assign launch_serv_mikrokopter(tab_mikrokopter); };
}

process Timer_main_mikrokopter(bool &tick_main_mikrokopter, urgent broadcast chan &shuttimer_main_mikrokopter) {

clock x;
state
    shutdown { ; 10000 },
    start { x <= 100 };
init
    start;
trans
    start -> start { guard x==100; assign tick_main_mikrokopter:= true, x:=0; },
    start -> shutdown { sync shuttimer_main_mikrokopter?; };
}

process Manager_main_mikrokopter(urgent broadcast chan &exe, bool &lock_main_mikrokopter, bool &shut_mikrokopter, urgent broadcast chan &go_main_mikrokopter, urgent broadcast chan &begin_main_mikrokopter, urgent broadcast chan &inter_main_mikrokopter, cell_mikrokopter &turn_main_mikrokopter , cell_mikrokopter &tab_mikrokopter[size_mikrokopter], bool &finished_main_mikrokopter, bool &sched_mikrokopter, urgent broadcast chan &shuttimer_main_mikrokopter, bool &tick_main_mikrokopter) {


int i:= 0;
int j:= 0;int count:= 0;
state
    start { ; 10000 },
    manage { ; 10000 },
    shutdown { ; 10000 };
init
    start;
trans
    start -> shutdown { guard shut_mikrokopter && tick_main_mikrokopter && next_mikrokopter(i,tab_mikrokopter,4)==size_mikrokopter-1; sync shuttimer_main_mikrokopter!; },
    manage -> manage { guard lock_main_mikrokopter && i<size_mikrokopter-1; sync inter_main_mikrokopter!; assign update_mikrokopter (finished_main_mikrokopter, j, tab_mikrokopter),
j:= i, i:= next_mikrokopter (i+1, tab_mikrokopter, 4), turn_main_mikrokopter := tab_mikrokopter[i]; },
    manage -> manage { guard lock_main_mikrokopter && i<size_mikrokopter-1; sync begin_main_mikrokopter!; assign update_mikrokopter (finished_main_mikrokopter, j, tab_mikrokopter),
j:= i, i:= next_mikrokopter (i+1, tab_mikrokopter, 4), turn_main_mikrokopter := tab_mikrokopter[i]; },
    manage -> manage { guard tick_main_mikrokopter; sync exe!; assign count:= count+1, tick_main_mikrokopter:= false; },
    manage -> start { guard lock_main_mikrokopter && i == size_mikrokopter-1; sync exe!; assign update_mikrokopter (finished_main_mikrokopter, j, tab_mikrokopter), i:= 0, sched_mikrokopter:= sched_cntrl_mikrokopter(tab_mikrokopter), finished_main_mikrokopter:= false; },
    start -> manage { guard !(shut_mikrokopter && next_mikrokopter(i,tab_mikrokopter,4)==size_mikrokopter-1) && tick_main_mikrokopter; sync go_main_mikrokopter!; assign tick_main_mikrokopter:= false, i:= next_mikrokopter (i, tab_mikrokopter, 4), turn_main_mikrokopter := tab_mikrokopter[i]; };
}

process Perm_main_mikrokopter(broadcast chan &end_spawn_main_mikrokopter, urgent broadcast chan &go_main_mikrokopter,  bool &lock_main_mikrokopter, urgent broadcast chan &exe, bool &mutex_mikrokopter[length_mut_mikrokopter], bool &ports[nports]) {


clock x;
bool shift:= true;
state
    start_ { ; 10000 },
    start_2 { x<=1 },
    main_ { ; 10000 },
    main_2 { x<=1 },
    pause_main_ { ; 10000 };
init
    start_;
trans
    pause_main_ -> main_ { sync go_main_mikrokopter?; assign shift:= false, lock_main_mikrokopter:= false, x:=0; },
    start_ -> start_2 { guard !mutex_mikrokopter[2]/*in conflict with mk_comm_start_comm*/ && !mutex_mikrokopter[3]/*in conflict with mk_comm_poll_comm*/ && !mutex_mikrokopter[4]/*in conflict with mk_comm_nodata_comm*/ && !mutex_mikrokopter[5]/*in conflict with mk_comm_recv_comm*/ && !ports[1]; sync exe!; assign x:=0, mutex_mikrokopter[0]:= true, ports[1]:= true; },
    start_2 -> main_ { guard x>0; sync end_spawn_main_mikrokopter!; assign x:=0, mutex_mikrokopter[0]:= false, ports[1]:= false; },
    main_ -> main_2 { guard !mutex_mikrokopter[2]/*in conflict with mk_comm_start_comm*/ && !mutex_mikrokopter[4]/*in conflict with mk_comm_nodata_comm*/ && !mutex_mikrokopter[5]/*in conflict with mk_comm_recv_comm*/ && !ports[0] /* uses (out) the port rotor_measure of the component mikrokopter */ && !ports[1]; sync exe!; assign x:=0, mutex_mikrokopter[1]:= true, ports[0]:= true, ports[1]:= true; },
    main_2 -> pause_main_ { guard x>0; assign update_lock_mikrokopter(shift, lock_main_mikrokopter), mutex_mikrokopter[1]:= false, ports[0]:= false, ports[1]:= false; };
}

process start_mikrokopter_(urgent broadcast chan &begin_main_mikrokopter, urgent broadcast chan &inter_main_mikrokopter, bool &lock_main_mikrokopter,
 const int instance, cell_mikrokopter &turn_main_mikrokopter, bool &finished_main_mikrokopter, urgent broadcast chan &exe, bool &mutex_mikrokopter[length_mut_mikrokopter], bool &ports[nports]) {


clock x;
state
    start_ { ; 10000 },
    start_2 { x<=1 },
    monitor_ { ; 10000 },
    monitor_2 { x<=1 },
    stop_ { ; 10000 },
    stop_2 { x<=1 },
    ether_ { ; 10000 };
init
    ether_;
trans
    ether_ -> start_ { guard turn_main_mikrokopter.name == start_mikrokopter && turn_main_mikrokopter.inst == instance && turn_main_mikrokopter.status == RUN_mikrokopter; sync begin_main_mikrokopter?; assign lock_main_mikrokopter:= false, x:= 0; },
    start_ -> start_2 { guard !mutex_mikrokopter[2]/*in conflict with mk_comm_start_comm*/ && !mutex_mikrokopter[4]/*in conflict with mk_comm_nodata_comm*/ && !mutex_mikrokopter[5]; sync exe!; assign x:=0, mutex_mikrokopter[6]:= true; },
    start_2 -> monitor_ { guard x>0; assign x:=0, mutex_mikrokopter[6]:= false; },
    monitor_ -> monitor_2 { guard !mutex_mikrokopter[2]/*in conflict with mk_comm_start_comm*/ && !mutex_mikrokopter[4]/*in conflict with mk_comm_nodata_comm*/ && !mutex_mikrokopter[5]; sync exe!; assign x:=0, mutex_mikrokopter[7]:= true; },
    monitor_2 -> ether_ { guard x>0; assign lock_main_mikrokopter:= true, finished_main_mikrokopter:= true, mutex_mikrokopter[7]:= false; },
    stop_ -> stop_2 { guard !mutex_mikrokopter[2]/*in conflict with mk_comm_start_comm*/ && !mutex_mikrokopter[4]/*in conflict with mk_comm_nodata_comm*/ && !mutex_mikrokopter[5]; sync exe!; assign x:=0, mutex_mikrokopter[8]:= true; },
    stop_2 -> ether_ { guard x>0; assign lock_main_mikrokopter:= true, finished_main_mikrokopter:= true, mutex_mikrokopter[8]:= false; },
    ether_ -> stop_ { guard turn_main_mikrokopter.name == start_mikrokopter && turn_main_mikrokopter.inst == instance && turn_main_mikrokopter.status == STOP_mikrokopter; sync inter_main_mikrokopter?; assign lock_main_mikrokopter:= false, x:= 0; };
}

process servo_mikrokopter_(urgent broadcast chan &begin_main_mikrokopter, urgent broadcast chan &inter_main_mikrokopter, bool &lock_main_mikrokopter,
 const int instance, cell_mikrokopter &turn_main_mikrokopter, bool &finished_main_mikrokopter, urgent broadcast chan &exe, bool &mutex_mikrokopter[length_mut_mikrokopter], bool &ports[nports]) {


clock x;
state
    start_ { x<=1 },
    main_ { ; 10000 },
    main_2 { x<=1 },
    stop_ { ; 10000 },
    stop_2 { x<=1 },
    ether_ { ; 10000 };
init
    ether_;
trans
    ether_ -> start_ { guard turn_main_mikrokopter.name == servo_mikrokopter && turn_main_mikrokopter.inst == instance && turn_main_mikrokopter.status == RUN_mikrokopter; sync begin_main_mikrokopter?; assign lock_main_mikrokopter:= false, x:= 0; },
    start_ -> main_ { guard x>0; assign x:=0; },
    main_ -> main_2 { guard !mutex_mikrokopter[2]/*in conflict with mk_comm_start_comm*/ && !mutex_mikrokopter[4]/*in conflict with mk_comm_nodata_comm*/ && !mutex_mikrokopter[5]/*in conflict with mk_comm_recv_comm*/ && !ports[3]; sync exe!; assign x:=0, mutex_mikrokopter[9]:= true, ports[3]:= true; },
    main_2 -> stop_ { guard x>0; assign x:=0, mutex_mikrokopter[9]:= false, ports[3]:= false; },
    stop_ -> stop_2 { guard !mutex_mikrokopter[2]/*in conflict with mk_comm_start_comm*/ && !mutex_mikrokopter[4]/*in conflict with mk_comm_nodata_comm*/ && !mutex_mikrokopter[5]; sync exe!; assign x:=0, mutex_mikrokopter[10]:= true; },
    stop_2 -> ether_ { guard x>0; assign lock_main_mikrokopter:= true, finished_main_mikrokopter:= true, mutex_mikrokopter[10]:= false; },
    ether_ -> stop_ { guard turn_main_mikrokopter.name == servo_mikrokopter && turn_main_mikrokopter.inst == instance && turn_main_mikrokopter.status == STOP_mikrokopter; sync inter_main_mikrokopter?; assign lock_main_mikrokopter:= false, x:= 0; };
}

process Perm_comm_mikrokopter(broadcast chan &end_spawn_comm_mikrokopter, broadcast chan &end_spawn_main_mikrokopter, urgent broadcast chan &exe, bool &mutex_mikrokopter[length_mut_mikrokopter], bool &ports[nports]) {


clock x;
state
    unspawned { ; 10000 },
    start_ { ; 10000 },
    start_2 { x<=1 },
    poll_ { ; 10000 },
    poll_2 { x<=1000 },
    nodata_ { ; 10000 },
    nodata_2 { x<=1 },
    recv_ { ; 10000 },
    recv_2 { x<=1 };
branchpoint
    poll_b,
    recv_b;
init
    unspawned;
trans
    unspawned -> start_ { sync end_spawn_main_mikrokopter?; assign x:=0; },
    start_ -> start_2 { guard !mutex_mikrokopter[0]/*in conflict with mk_main_init_main*/ && !mutex_mikrokopter[1]/*in conflict with mk_main_perm_main*/ && !mutex_mikrokopter[6]/*in conflict with mk_start_start_start*/ && !mutex_mikrokopter[7]/*in conflict with mk_start_monitor_start*/ && !mutex_mikrokopter[8]/*in conflict with mk_start_stop_start*/ && !mutex_mikrokopter[9]/*in conflict with mk_servo_main_servo*/ && !mutex_mikrokopter[10]; sync exe!; assign x:=0, mutex_mikrokopter[2]:= true; },
    start_2 -> poll_ { guard x>0; sync end_spawn_comm_mikrokopter!; assign x:=0, mutex_mikrokopter[2]:= false; },
    poll_ -> poll_2 { guard !mutex_mikrokopter[0]; sync exe!; assign x:=0, mutex_mikrokopter[3]:= true; },
    poll_2 -> poll_b { guard x>0; },
    poll_b -> nodata_ { assign x:=0, mutex_mikrokopter[3]:= false; probability 2; },
    poll_b -> recv_ { assign x:=0, mutex_mikrokopter[3]:= false; probability 998; },
    nodata_ -> nodata_2 { guard !mutex_mikrokopter[0]/*in conflict with mk_main_init_main*/ && !mutex_mikrokopter[1]/*in conflict with mk_main_perm_main*/ && !mutex_mikrokopter[6]/*in conflict with mk_start_start_start*/ && !mutex_mikrokopter[7]/*in conflict with mk_start_monitor_start*/ && !mutex_mikrokopter[8]/*in conflict with mk_start_stop_start*/ && !mutex_mikrokopter[9]/*in conflict with mk_servo_main_servo*/ && !mutex_mikrokopter[10]/*in conflict with mk_servo_stop_servo*/ && !ports[1]; sync exe!; assign x:=0, mutex_mikrokopter[4]:= true, ports[1]:= true; },
    nodata_2 -> poll_ { guard x>0; assign x:=0, mutex_mikrokopter[4]:= false, ports[1]:= false; },
    recv_ -> recv_2 { guard !mutex_mikrokopter[0]/*in conflict with mk_main_init_main*/ && !mutex_mikrokopter[1]/*in conflict with mk_main_perm_main*/ && !mutex_mikrokopter[6]/*in conflict with mk_start_start_start*/ && !mutex_mikrokopter[7]/*in conflict with mk_start_monitor_start*/ && !mutex_mikrokopter[8]/*in conflict with mk_start_stop_start*/ && !mutex_mikrokopter[9]/*in conflict with mk_servo_main_servo*/ && !mutex_mikrokopter[10]/*in conflict with mk_servo_stop_servo*/ && !ports[1]; sync exe!; assign x:=0, mutex_mikrokopter[5]:= true, ports[1]:= true; },
    recv_2 -> recv_b { guard x>0; },
    recv_b -> poll_ { assign x:=0, mutex_mikrokopter[5]:= false, ports[1]:= false; probability 45; },
    recv_b -> recv_ { assign x:=0, mutex_mikrokopter[5]:= false, ports[1]:= false; probability 55; };
}

process control_pom(urgent broadcast chan &recv_pom, urgent broadcast chan &exe, bool &shut_pom, broadcast chan &end_spawn_filter_pom, int[kill_pom,nserv_pom-1] &req_pom) {

clock x;
state
    shutdown { ; 10000 },
    receive { ; 10000 },
    unspawned { ; 10000 };
init
    unspawned;
trans
    unspawned -> receive { sync end_spawn_filter_pom?; },
    receive -> shutdown { sync recv_pom?; assign shut_pom:= true; };
}

process Timer_io_pom(bool &tick_io_pom, urgent broadcast chan &shuttimer_io_pom) {

clock x;
state
    shutdown { ; 10000 },
    start { x <= 100 };
init
    start;
trans
    start -> start { guard x==100; assign tick_io_pom:= true, x:=0; },
    start -> shutdown { sync shuttimer_io_pom?; };
}

process Manager_io_pom(urgent broadcast chan &exe, bool &lock_io_pom, bool &shut_pom, urgent broadcast chan &go_io_pom, urgent broadcast chan &shuttimer_io_pom, bool &tick_io_pom) {

int count:= 0;
state
    start { ; 10000 },
    manage { ; 10000 },
    shutdown { ; 10000 };
init
    start;
trans
    start -> shutdown { guard shut_pom && tick_io_pom; sync shuttimer_io_pom!; },
    manage -> manage { guard tick_io_pom; sync exe!; assign count:= count+1, tick_io_pom:= false; },
    manage -> start { guard lock_io_pom; sync exe!; },
    start -> manage { guard !(shut_pom) && tick_io_pom; sync go_io_pom!; assign tick_io_pom:= false; };
}

process Perm_io_pom(broadcast chan &end_spawn_io_pom, urgent broadcast chan &go_io_pom,  bool &lock_io_pom, urgent broadcast chan &exe, bool &mutex_pom[length_mut_pom], bool &ports[nports]) {


clock x;
bool shift:= true;
state
    start_ { ; 10000 },
    start_2 { x<=1 },
    read_ { x<=1 },
    insert_ { ; 10000 },
    insert_2 { x<=1 },
    pause_read_ { ; 10000 };
branchpoint
    read_b;
init
    start_;
trans
    pause_read_ -> read_ { sync go_io_pom?; assign shift:= false, lock_io_pom:= false, x:=0; },
    start_ -> start_2 { guard !mutex_pom[2]/*in conflict with pom_filter_start_filter*/ && !mutex_pom[3]; sync exe!; assign x:=0, mutex_pom[0]:= true; },
    start_2 -> read_ { guard x>0; sync end_spawn_io_pom!; assign x:=0, mutex_pom[0]:= false; },
    read_ -> read_b { guard x>0; },
    read_b -> pause_read_ { assign update_lock_pom(shift, lock_io_pom); probability 1; },
    read_b -> insert_ { assign x:=0; probability 9; },
    insert_ -> insert_2 { guard !mutex_pom[2]/*in conflict with pom_filter_start_filter*/ && !mutex_pom[3]; sync exe!; assign x:=0, mutex_pom[1]:= true; },
    insert_2 -> pause_read_ { guard x>0; assign update_lock_pom(shift, lock_io_pom), mutex_pom[1]:= false; };
}

process Timer_filter_pom(bool &tick_filter_pom, urgent broadcast chan &shuttimer_filter_pom, broadcast chan &end_spawn_io_pom) {

clock x;
state
    shutdown { ; 10000 },
    start { x <= 100 },
    idle { ; 10000 };
init
    idle;
trans
    start -> start { guard x==100; assign tick_filter_pom:= true, x:=0; },
    start -> shutdown { sync shuttimer_filter_pom?; },
    idle -> start { sync end_spawn_io_pom?; assign x:=0; };
}

process Manager_filter_pom(urgent broadcast chan &exe, bool &lock_filter_pom, bool &shut_pom, urgent broadcast chan &go_filter_pom, urgent broadcast chan &shuttimer_filter_pom, bool &tick_filter_pom) {

int count:= 0;
state
    start { ; 10000 },
    manage { ; 10000 },
    shutdown { ; 10000 };
init
    start;
trans
    start -> shutdown { guard shut_pom && tick_filter_pom; sync shuttimer_filter_pom!; },
    manage -> manage { guard tick_filter_pom; sync exe!; assign count:= count+1, tick_filter_pom:= false; },
    manage -> start { guard lock_filter_pom; sync exe!; },
    start -> manage { guard !(shut_pom) && tick_filter_pom; sync go_filter_pom!; assign tick_filter_pom:= false; };
}

process Perm_filter_pom(broadcast chan &end_spawn_filter_pom, broadcast chan &end_spawn_io_pom, urgent broadcast chan &go_filter_pom,  bool &lock_filter_pom, urgent broadcast chan &exe, bool &mutex_pom[length_mut_pom], bool &ports[nports]) {


clock x;
bool shift:= true;
state
    unspawned { ; 10000 },
    start_ { ; 10000 },
    start_2 { x<=5 },
    exec_ { ; 10000 },
    exec_2 { x<=60 },
    pause_exec_ { ; 10000 };
init
    unspawned;
trans
    unspawned -> start_ { sync end_spawn_io_pom?; assign x:=0; },
    pause_exec_ -> exec_ { sync go_filter_pom?; assign shift:= false, lock_filter_pom:= false, x:=0; },
    start_ -> start_2 { guard !mutex_pom[0]/*in conflict with pom_io_start_io*/ && !mutex_pom[1]/*in conflict with pom_io_insert_io*/ && !ports[2]; sync exe!; assign x:=0, mutex_pom[2]:= true, ports[2]:= true; },
    start_2 -> exec_ { guard x>0; sync end_spawn_filter_pom!; assign x:=0, mutex_pom[2]:= false, ports[2]:= false; },
    exec_ -> exec_2 { guard !mutex_pom[0]/*in conflict with pom_io_start_io*/ && !mutex_pom[1]/*in conflict with pom_io_insert_io*/ && !ports[2]; sync exe!; assign x:=0, mutex_pom[3]:= true, ports[2]:= true; },
    exec_2 -> pause_exec_ { guard x>0; assign update_lock_pom(shift, lock_filter_pom), mutex_pom[3]:= false, ports[2]:= false; };
}

process control_nhfc(bool &s_nhfc, urgent broadcast chan &recv_nhfc, urgent broadcast chan &exe, bool &shut_nhfc, urgent broadcast chan &recv_urg_nhfc, cell_nhfc &tab_nhfc[size_nhfc], bool &sched_nhfc, broadcast chan &end_spawn_main_nhfc, int[none_nhfc,nserv_nhfc-1] &req_nhfc) {

clock x;
state
    shutdown { ; 10000 },
    receive { ; 10000 },
    unspawned { ; 10000 },
    decode,
    manage,
    wait { ; 10000 },
    finish;
commit
    decode;
urgent
    manage,
    finish;
init
    unspawned;
trans
    unspawned -> receive { sync end_spawn_main_nhfc?; assign s_nhfc:= true; },
    receive -> decode { guard sched_nhfc; sync recv_urg_nhfc?; assign sched_nhfc:= false, s_nhfc:= false; },
    decode -> finish { guard req_nhfc < 0; assign interrupt_cntrl_nhfc(req_nhfc,tab_nhfc,shut_nhfc); },
    manage -> finish { assign slot_search_nhfc (req_nhfc, tab_nhfc); },
    decode -> manage { guard req_nhfc >=servo_nhfc  && req_nhfc <=servo_nhfc; },
    finish -> receive { guard !shut_nhfc; assign launch_serv_nhfc(tab_nhfc), s_nhfc:= true; },
    receive -> decode { guard !sched_nhfc; sync recv_nhfc?; assign s_nhfc:= false; },
    finish -> wait { guard shut_nhfc; },
    wait -> shutdown { guard off_signal_nhfc(tab_nhfc); sync exe!; assign launch_serv_nhfc(tab_nhfc); };
}

process Timer_main_nhfc(bool &tick_main_nhfc, urgent broadcast chan &shuttimer_main_nhfc) {

clock x;
state
    shutdown { ; 10000 },
    start { x <= 100 };
init
    start;
trans
    start -> start { guard x==100; assign tick_main_nhfc:= true, x:=0; },
    start -> shutdown { sync shuttimer_main_nhfc?; };
}

process Manager_main_nhfc(urgent broadcast chan &exe, bool &lock_main_nhfc, bool &shut_nhfc, urgent broadcast chan &go_main_nhfc, urgent broadcast chan &begin_main_nhfc, urgent broadcast chan &inter_main_nhfc, cell_nhfc &turn_main_nhfc , cell_nhfc &tab_nhfc[size_nhfc], bool &finished_main_nhfc, bool &sched_nhfc, urgent broadcast chan &shuttimer_main_nhfc, bool &tick_main_nhfc) {


int i:= 0;
int j:= 0;int count:= 0;
state
    start { ; 10000 },
    manage { ; 10000 },
    shutdown { ; 10000 };
init
    start;
trans
    start -> shutdown { guard shut_nhfc && tick_main_nhfc && next_nhfc(i,tab_nhfc,2)==size_nhfc-1; sync shuttimer_main_nhfc!; },
    manage -> manage { guard lock_main_nhfc && i<size_nhfc-1; sync inter_main_nhfc!; assign update_nhfc (finished_main_nhfc, j, tab_nhfc),
j:= i, i:= next_nhfc (i+1, tab_nhfc, 2), turn_main_nhfc := tab_nhfc[i]; },
    manage -> manage { guard lock_main_nhfc && i<size_nhfc-1; sync begin_main_nhfc!; assign update_nhfc (finished_main_nhfc, j, tab_nhfc),
j:= i, i:= next_nhfc (i+1, tab_nhfc, 2), turn_main_nhfc := tab_nhfc[i]; },
    manage -> manage { guard tick_main_nhfc; sync exe!; assign count:= count+1, tick_main_nhfc:= false; },
    manage -> start { guard lock_main_nhfc && i == size_nhfc-1; sync exe!; assign update_nhfc (finished_main_nhfc, j, tab_nhfc), i:= 0, sched_nhfc:= sched_cntrl_nhfc(tab_nhfc), finished_main_nhfc:= false; },
    start -> manage { guard !(shut_nhfc && next_nhfc(i,tab_nhfc,2)==size_nhfc-1) && tick_main_nhfc; sync go_main_nhfc!; assign tick_main_nhfc:= false, i:= next_nhfc (i, tab_nhfc, 2), turn_main_nhfc := tab_nhfc[i]; };
}

process Perm_main_nhfc(broadcast chan &end_spawn_main_nhfc, urgent broadcast chan &go_main_nhfc,  bool &lock_main_nhfc, urgent broadcast chan &exe, bool &ports[nports]) {


clock x;
bool shift:= true;
state
    start_ { x<=3 },
    init_ { ; 10000 },
    init_2 { x<=1 },
    control_ { ; 10000 },
    control_2 { x<=1 },
    pause_init_ { ; 10000 },
    pause_control_ { ; 10000 };
branchpoint
    init_b;
init
    start_;
trans
    pause_init_ -> init_ { sync go_main_nhfc?; assign shift:= false, lock_main_nhfc:= false, x:=0; },
    pause_control_ -> control_ { sync go_main_nhfc?; assign shift:= false, lock_main_nhfc:= false, x:=0; },
    start_ -> init_ { guard x>0; sync end_spawn_main_nhfc!; assign x:=0; },
    init_ -> init_2 { guard !ports[3]; sync exe!; assign x:=0, ports[3]:= true; },
    init_2 -> init_b { guard x>0; },
    init_b -> pause_init_ { assign update_lock_nhfc(shift, lock_main_nhfc), ports[3]:= false; probability 10; },
    init_b -> control_ { assign x:=0, ports[3]:= false; probability 1; },
    control_ -> control_2 { guard !ports[2] /* uses (in) the port state of the component pom */ && !ports[3]; sync exe!; assign x:=0, ports[2]:= true, ports[3]:= true; },
    control_2 -> pause_control_ { guard x>0; assign update_lock_nhfc(shift, lock_main_nhfc), ports[2]:= false, ports[3]:= false; };
}

process servo_nhfc_(urgent broadcast chan &begin_main_nhfc, urgent broadcast chan &inter_main_nhfc, bool &lock_main_nhfc,
 const int instance, cell_nhfc &turn_main_nhfc, bool &finished_main_nhfc, urgent broadcast chan &exe, bool &ports[nports]) {


clock x;
state
    start_ { ; 10000 },
    start_2 { x<=1 },
    ether_ { ; 10000 };
init
    ether_;
trans
    ether_ -> start_ { guard turn_main_nhfc.name == servo_nhfc && turn_main_nhfc.inst == instance && turn_main_nhfc.status == RUN_nhfc; sync begin_main_nhfc?; assign lock_main_nhfc:= false, x:= 0; },
    start_ -> start_2 { guard !ports[4]; sync exe!; assign x:=0, ports[4]:= true; },
    start_2 -> ether_ { guard x>0; assign lock_main_nhfc:= true, finished_main_nhfc:= true, ports[4]:= false; },
    ether_ -> ether_ { guard turn_main_nhfc.name == servo_nhfc && turn_main_nhfc.inst == instance && turn_main_nhfc.status == STOP_nhfc; sync inter_main_nhfc?; assign finished_main_nhfc:= true; };
}

process control_maneuver(bool &s_maneuver, urgent broadcast chan &recv_maneuver, urgent broadcast chan &exe, bool &shut_maneuver, urgent broadcast chan &recv_urg_maneuver, cell_maneuver &tab_maneuver[size_maneuver], bool &sched_maneuver, broadcast chan &end_spawn_exec_maneuver, int[none_maneuver,nserv_maneuver-1] &req_maneuver, bool &mutex_maneuver[length_mut_maneuver]) {

clock x;
state
    shutdown { ; 10000 },
    receive { ; 10000 },
    unspawned { ; 10000 },
    decode,
    manage,
    wait { ; 10000 },
    finish,
    set_bounds_ { ; 10000 },
    set_bounds_2 { x<=1 };
commit
    decode;
urgent
    manage,
    finish;
init
    unspawned;
trans
    unspawned -> receive { sync end_spawn_exec_maneuver?; assign s_maneuver:= true; },
    receive -> decode { guard sched_maneuver; sync recv_urg_maneuver?; assign sched_maneuver:= false, s_maneuver:= false; },
    decode -> finish { guard req_maneuver < 0; assign interrupt_cntrl_maneuver(req_maneuver,tab_maneuver,shut_maneuver); },
    manage -> finish { assign slot_search_maneuver (req_maneuver, tab_maneuver); },
    decode -> manage { guard req_maneuver >=set_current_state_maneuver  && req_maneuver <=wait_maneuver; },
    finish -> receive { guard !shut_maneuver; assign launch_serv_maneuver(tab_maneuver), s_maneuver:= true; },
    receive -> decode { guard !sched_maneuver; sync recv_maneuver?; assign s_maneuver:= false; },
    decode -> set_bounds_ { guard req_maneuver==set_bounds_maneuver; },
    set_bounds_ -> set_bounds_2 { guard !mutex_maneuver[0]/*in conflict with mv_plan_start_plan*/ && !mutex_maneuver[10]/*in conflict with mv_waypoint_plan_waypoint*/ && !mutex_maneuver[11]/*in conflict with mv_waypoint_add_waypoint*/ && !mutex_maneuver[6]/*in conflict with mv_take_off_plan_take_off*/ && !mutex_maneuver[7]; sync exe!; assign x:=0, mutex_maneuver[4]:= true; },
    set_bounds_2 -> finish { guard x>0; assign mutex_maneuver[4]:= false; },
    finish -> wait { guard shut_maneuver; },
    wait -> shutdown { guard off_signal_maneuver(tab_maneuver); sync exe!; assign launch_serv_maneuver(tab_maneuver); };
}

process Timer_plan_maneuver(bool &tick_plan_maneuver, urgent broadcast chan &shuttimer_plan_maneuver) {

clock x;
state
    shutdown { ; 10000 },
    start { x <= 500 };
init
    start;
trans
    start -> start { guard x==500; assign tick_plan_maneuver:= true, x:=0; },
    start -> shutdown { sync shuttimer_plan_maneuver?; };
}

process Manager_plan_maneuver(urgent broadcast chan &exe, bool &lock_plan_maneuver, bool &shut_maneuver, urgent broadcast chan &begin_plan_maneuver, urgent broadcast chan &inter_plan_maneuver, cell_maneuver &turn_plan_maneuver , cell_maneuver &tab_maneuver[size_maneuver], bool &finished_plan_maneuver, bool &sched_maneuver, urgent broadcast chan &shuttimer_plan_maneuver, bool &tick_plan_maneuver) {


int i:= 0;
int j:= 0;int count:= 0;
state
    start { ; 10000 },
    manage { ; 10000 },
    shutdown { ; 10000 };
init
    start;
trans
    start -> shutdown { guard shut_maneuver && tick_plan_maneuver && next_maneuver(i,tab_maneuver,8)==size_maneuver-1; sync shuttimer_plan_maneuver!; },
    manage -> manage { guard lock_plan_maneuver && i<size_maneuver-1; sync inter_plan_maneuver!; assign update_maneuver (finished_plan_maneuver, j, tab_maneuver),
j:= i, i:= next_maneuver (i+1, tab_maneuver, 8), turn_plan_maneuver := tab_maneuver[i]; },
    manage -> manage { guard lock_plan_maneuver && i<size_maneuver-1; sync begin_plan_maneuver!; assign update_maneuver (finished_plan_maneuver, j, tab_maneuver),
j:= i, i:= next_maneuver (i+1, tab_maneuver, 8), turn_plan_maneuver := tab_maneuver[i]; },
    manage -> manage { guard tick_plan_maneuver; sync exe!; assign count:= count+1, tick_plan_maneuver:= false; },
    manage -> start { guard lock_plan_maneuver && i == size_maneuver-1; sync exe!; assign update_maneuver (finished_plan_maneuver, j, tab_maneuver), i:= 0, sched_maneuver:= sched_cntrl_maneuver(tab_maneuver), finished_plan_maneuver:= false; },
    start -> manage { guard !(shut_maneuver && next_maneuver(i,tab_maneuver,8)==size_maneuver-1) && tick_plan_maneuver; sync exe!; assign tick_plan_maneuver:= false, i:= next_maneuver (i, tab_maneuver, 8), turn_plan_maneuver := tab_maneuver[i]; };
}

process Perm_plan_maneuver(broadcast chan &end_spawn_plan_maneuver, urgent broadcast chan &exe, bool &mutex_maneuver[length_mut_maneuver], bool &ports[nports]) {


clock x;
state
    start_ { ; 10000 },
    start_2 { x<=3 },
    ether_ { ; 10000 };
init
    start_;
trans
    start_ -> start_2 { guard !mutex_maneuver[1]/*in conflict with mv_exec_start_exec*/ && !mutex_maneuver[2]/*in conflict with mv_exec_wait_exec*/ && !mutex_maneuver[3]/*in conflict with mv_exec_main_exec*/ && !mutex_maneuver[4]; sync exe!; assign x:=0, mutex_maneuver[0]:= true; },
    start_2 -> ether_ { guard x>0; sync end_spawn_plan_maneuver!; assign x:=0, mutex_maneuver[0]:= false; };
}

process set_current_state_maneuver_(urgent broadcast chan &begin_plan_maneuver, urgent broadcast chan &inter_plan_maneuver, bool &lock_plan_maneuver,
 const int instance, cell_maneuver &turn_plan_maneuver, bool &finished_plan_maneuver, urgent broadcast chan &exe, bool &mutex_maneuver[length_mut_maneuver], bool &ports[nports]) {


clock x;
state
    start_ { ; 10000 },
    start_2 { x<=2 },
    ether_ { ; 10000 };
init
    ether_;
trans
    ether_ -> start_ { guard turn_plan_maneuver.name == set_current_state_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == RUN_maneuver; sync begin_plan_maneuver?; assign lock_plan_maneuver:= false, x:= 0; },
    start_ -> start_2 { guard !mutex_maneuver[2]/*in conflict with mv_exec_wait_exec*/ && !mutex_maneuver[3]/*in conflict with mv_exec_main_exec*/ && !ports[2]; sync exe!; assign x:=0, mutex_maneuver[5]:= true, ports[2]:= true; },
    start_2 -> ether_ { guard x>0; assign lock_plan_maneuver:= true, finished_plan_maneuver:= true, mutex_maneuver[5]:= false, ports[2]:= false; },
    ether_ -> ether_ { guard turn_plan_maneuver.name == set_current_state_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == STOP_maneuver; sync inter_plan_maneuver?; assign finished_plan_maneuver:= true; };
}

process take_off_maneuver_(urgent broadcast chan &begin_plan_maneuver, urgent broadcast chan &inter_plan_maneuver, bool &lock_plan_maneuver,
 const int instance, cell_maneuver &turn_plan_maneuver, bool &finished_plan_maneuver, urgent broadcast chan &exe, bool &mutex_maneuver[length_mut_maneuver], bool &ports[nports]) {


clock x;
state
    start_ { ; 10000 },
    start_2 { x<=200 },
    exec_ { ; 10000 },
    exec_2 { x<=100 },
    wait_ { ; 10000 },
    wait_2 { x<=1 },
    stop_ { ; 10000 },
    stop_2 { x<=1 },
    pause_exec_ { ; 10000 },
    pause_wait_ { ; 10000 },
    ether_ { ; 10000 };
branchpoint
    exec_b,
    wait_b;
init
    ether_;
trans
    ether_ -> start_ { guard turn_plan_maneuver.name == take_off_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == RUN_maneuver; sync begin_plan_maneuver?; assign lock_plan_maneuver:= false, x:= 0; },
    start_ -> start_2 { guard !mutex_maneuver[4]; sync exe!; assign x:=0, mutex_maneuver[6]:= true; },
    start_2 -> exec_ { guard x>0; assign x:=0, mutex_maneuver[6]:= false; },
    exec_ -> exec_2 { guard !mutex_maneuver[1]/*in conflict with mv_exec_start_exec*/ && !mutex_maneuver[2]/*in conflict with mv_exec_wait_exec*/ && !mutex_maneuver[3]/*in conflict with mv_exec_main_exec*/ && !mutex_maneuver[4]; sync exe!; assign x:=0, mutex_maneuver[7]:= true; },
    exec_2 -> exec_b { guard x>0; },
    exec_b -> pause_exec_ { assign lock_plan_maneuver:= true, mutex_maneuver[7]:= false; probability 1; },
    exec_b -> wait_ { assign x:=0, mutex_maneuver[7]:= false; probability 7; },
    wait_ -> wait_2 { guard !mutex_maneuver[1]/*in conflict with mv_exec_start_exec*/ && !mutex_maneuver[3]; sync exe!; assign x:=0, mutex_maneuver[8]:= true; },
    wait_2 -> wait_b { guard x>0; },
    wait_b -> pause_wait_ { assign lock_plan_maneuver:= true, mutex_maneuver[8]:= false; probability 2; },
    wait_b -> ether_ { assign lock_plan_maneuver:= true, finished_plan_maneuver:= true, mutex_maneuver[8]:= false; probability 1; },
    stop_ -> stop_2 { guard !mutex_maneuver[1]/*in conflict with mv_exec_start_exec*/ && !mutex_maneuver[2]/*in conflict with mv_exec_wait_exec*/ && !mutex_maneuver[3]; sync exe!; assign x:=0, mutex_maneuver[9]:= true; },
    stop_2 -> ether_ { guard x>0; assign lock_plan_maneuver:= true, finished_plan_maneuver:= true, mutex_maneuver[9]:= false; },
    pause_exec_ -> exec_ { guard turn_plan_maneuver.name == take_off_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == RUN_maneuver; sync begin_plan_maneuver?; assign lock_plan_maneuver:= false, x:= 0; },
    pause_wait_ -> wait_ { guard turn_plan_maneuver.name == take_off_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == RUN_maneuver; sync begin_plan_maneuver?; assign lock_plan_maneuver:= false, x:= 0; },
    pause_exec_ -> stop_ { guard turn_plan_maneuver.name == take_off_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == STOP_maneuver; sync inter_plan_maneuver?; assign lock_plan_maneuver:= false, x:= 0; },
    pause_wait_ -> stop_ { guard turn_plan_maneuver.name == take_off_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == STOP_maneuver; sync inter_plan_maneuver?; assign lock_plan_maneuver:= false, x:= 0; },
    ether_ -> stop_ { guard turn_plan_maneuver.name == take_off_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == STOP_maneuver; sync inter_plan_maneuver?; assign lock_plan_maneuver:= false, x:= 0; };
}

process waypoint_maneuver_(urgent broadcast chan &begin_plan_maneuver, urgent broadcast chan &inter_plan_maneuver, bool &lock_plan_maneuver,
 const int instance, cell_maneuver &turn_plan_maneuver, bool &finished_plan_maneuver, urgent broadcast chan &exe, bool &mutex_maneuver[length_mut_maneuver], bool &ports[nports]) {


clock x;
state
    start_ { ; 10000 },
    start_2 { x<=300 },
    exec_ { ; 10000 },
    exec_2 { x<=100 },
    ether_ { ; 10000 };
init
    ether_;
trans
    ether_ -> start_ { guard turn_plan_maneuver.name == waypoint_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == RUN_maneuver; sync begin_plan_maneuver?; assign lock_plan_maneuver:= false, x:= 0; },
    start_ -> start_2 { guard !mutex_maneuver[4]; sync exe!; assign x:=0, mutex_maneuver[10]:= true; },
    start_2 -> exec_ { guard x>0; assign x:=0, mutex_maneuver[10]:= false; },
    exec_ -> exec_2 { guard !mutex_maneuver[1]/*in conflict with mv_exec_start_exec*/ && !mutex_maneuver[2]/*in conflict with mv_exec_wait_exec*/ && !mutex_maneuver[3]/*in conflict with mv_exec_main_exec*/ && !mutex_maneuver[4]; sync exe!; assign x:=0, mutex_maneuver[11]:= true; },
    exec_2 -> ether_ { guard x>0; assign lock_plan_maneuver:= true, finished_plan_maneuver:= true, mutex_maneuver[11]:= false; },
    ether_ -> ether_ { guard turn_plan_maneuver.name == waypoint_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == STOP_maneuver; sync inter_plan_maneuver?; assign finished_plan_maneuver:= true; };
}

process wait_maneuver_(urgent broadcast chan &begin_plan_maneuver, urgent broadcast chan &inter_plan_maneuver, bool &lock_plan_maneuver,
 const int instance, cell_maneuver &turn_plan_maneuver, bool &finished_plan_maneuver, urgent broadcast chan &exe, bool &mutex_maneuver[length_mut_maneuver], bool &ports[nports]) {


clock x;
state
    start_ { ; 10000 },
    start_2 { x<=1 },
    pause_start_ { ; 10000 },
    ether_ { ; 10000 };
branchpoint
    start_b;
init
    ether_;
trans
    ether_ -> start_ { guard turn_plan_maneuver.name == wait_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == RUN_maneuver; sync begin_plan_maneuver?; assign lock_plan_maneuver:= false, x:= 0; },
    start_ -> start_2 { guard !mutex_maneuver[1]/*in conflict with mv_exec_start_exec*/ && !mutex_maneuver[3]; sync exe!; assign x:=0, mutex_maneuver[12]:= true; },
    start_2 -> start_b { guard x>0; },
    start_b -> pause_start_ { assign lock_plan_maneuver:= true, mutex_maneuver[12]:= false; probability 100; },
    start_b -> ether_ { assign lock_plan_maneuver:= true, finished_plan_maneuver:= true, mutex_maneuver[12]:= false; probability 1; },
    pause_start_ -> start_ { guard turn_plan_maneuver.name == wait_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == RUN_maneuver; sync begin_plan_maneuver?; assign lock_plan_maneuver:= false, x:= 0; },
    pause_start_ -> ether_ { guard turn_plan_maneuver.name == wait_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == STOP_maneuver; sync inter_plan_maneuver?; assign finished_plan_maneuver:= true; },
    ether_ -> ether_ { guard turn_plan_maneuver.name == wait_maneuver && turn_plan_maneuver.inst == instance && turn_plan_maneuver.status == STOP_maneuver; sync inter_plan_maneuver?; assign finished_plan_maneuver:= true; };
}

process Timer_exec_maneuver(bool &tick_exec_maneuver, urgent broadcast chan &shuttimer_exec_maneuver, broadcast chan &end_spawn_plan_maneuver) {

clock x;
state
    shutdown { ; 10000 },
    start { x <= 500 },
    idle { ; 10000 };
init
    idle;
trans
    start -> start { guard x==500; assign tick_exec_maneuver:= true, x:=0; },
    start -> shutdown { sync shuttimer_exec_maneuver?; },
    idle -> start { sync end_spawn_plan_maneuver?; assign x:=0; };
}

process Manager_exec_maneuver(urgent broadcast chan &exe, bool &lock_exec_maneuver, bool &shut_maneuver, urgent broadcast chan &go_exec_maneuver, urgent broadcast chan &shuttimer_exec_maneuver, bool &tick_exec_maneuver) {

int count:= 0;
state
    start { ; 10000 },
    manage { ; 10000 },
    shutdown { ; 10000 };
init
    start;
trans
    start -> shutdown { guard shut_maneuver && tick_exec_maneuver; sync shuttimer_exec_maneuver!; },
    manage -> manage { guard tick_exec_maneuver; sync exe!; assign count:= count+1, tick_exec_maneuver:= false; },
    manage -> start { guard lock_exec_maneuver; sync exe!; },
    start -> manage { guard !(shut_maneuver) && tick_exec_maneuver; sync go_exec_maneuver!; assign tick_exec_maneuver:= false; };
}

process Perm_exec_maneuver(broadcast chan &end_spawn_exec_maneuver, broadcast chan &end_spawn_plan_maneuver, urgent broadcast chan &go_exec_maneuver,  bool &lock_exec_maneuver, urgent broadcast chan &exe, bool &mutex_maneuver[length_mut_maneuver], bool &ports[nports]) {


clock x;
bool shift:= true;
state
    unspawned { ; 10000 },
    start_ { ; 10000 },
    start_2 { x<=1 },
    wait_ { ; 10000 },
    wait_2 { x<=2 },
    main_ { ; 10000 },
    main_2 { x<=5 },
    pause_wait_ { ; 10000 },
    pause_main_ { ; 10000 };
branchpoint
    wait_b,
    main_b;
init
    unspawned;
trans
    unspawned -> start_ { sync end_spawn_plan_maneuver?; assign x:=0; },
    pause_wait_ -> wait_ { sync go_exec_maneuver?; assign shift:= false, lock_exec_maneuver:= false, x:=0; },
    pause_main_ -> main_ { sync go_exec_maneuver?; assign shift:= false, lock_exec_maneuver:= false, x:=0; },
    start_ -> start_2 { guard !mutex_maneuver[0]/*in conflict with mv_plan_start_plan*/ && !mutex_maneuver[7]/*in conflict with mv_plan_exec_take_off*/ && !mutex_maneuver[8]/*in conflict with mv_plan_exec_wait_take_off*/ && !mutex_maneuver[9]/*in conflict with mv_plan_exec_stop_take_off*/ && !mutex_maneuver[11]/*in conflict with mv_waypoint_add_waypoint*/ && !mutex_maneuver[12]/*in conflict with mv_plan_exec_wait_wait*/ && !ports[4]; sync exe!; assign x:=0, mutex_maneuver[1]:= true, ports[4]:= true; },
    start_2 -> wait_ { guard x>0; sync end_spawn_exec_maneuver!; assign x:=0, mutex_maneuver[1]:= false, ports[4]:= false; },
    wait_ -> wait_2 { guard !mutex_maneuver[0]/*in conflict with mv_plan_start_plan*/ && !mutex_maneuver[5]/*in conflict with mv_current_state_start_set_current_state*/ && !mutex_maneuver[7]/*in conflict with mv_plan_exec_take_off*/ && !mutex_maneuver[9]/*in conflict with mv_plan_exec_stop_take_off*/ && !mutex_maneuver[11]/*in conflict with mv_waypoint_add_waypoint*/ && !ports[2]; sync exe!; assign x:=0, mutex_maneuver[2]:= true, ports[2]:= true; },
    wait_2 -> wait_b { guard x>0; },
    wait_b -> pause_wait_ { assign update_lock_maneuver(shift, lock_exec_maneuver), mutex_maneuver[2]:= false, ports[2]:= false; probability 100; },
    wait_b -> main_ { assign x:=0, mutex_maneuver[2]:= false, ports[2]:= false; probability 3; },
    main_ -> main_2 { guard !mutex_maneuver[0]/*in conflict with mv_plan_start_plan*/ && !mutex_maneuver[5]/*in conflict with mv_current_state_start_set_current_state*/ && !mutex_maneuver[7]/*in conflict with mv_plan_exec_take_off*/ && !mutex_maneuver[8]/*in conflict with mv_plan_exec_wait_take_off*/ && !mutex_maneuver[9]/*in conflict with mv_plan_exec_stop_take_off*/ && !mutex_maneuver[11]/*in conflict with mv_waypoint_add_waypoint*/ && !mutex_maneuver[12]/*in conflict with mv_plan_exec_wait_wait*/ && !ports[2] /* uses (in) the port state of the component pom */ && !ports[4]; sync exe!; assign x:=0, mutex_maneuver[3]:= true, ports[2]:= true, ports[4]:= true; },
    main_2 -> main_b { guard x>0; },
    main_b -> wait_ { assign x:=0, mutex_maneuver[3]:= false, ports[2]:= false, ports[4]:= false; probability 1; },
    main_b -> pause_main_ { assign update_lock_maneuver(shift, lock_exec_maneuver), mutex_maneuver[3]:= false, ports[2]:= false, ports[4]:= false; probability 10; };
}

process control_optitrack(urgent broadcast chan &recv_optitrack, urgent broadcast chan &exe, bool &shut_optitrack, broadcast chan &end_spawn_publish_optitrack, int[kill_optitrack,nserv_optitrack-1] &req_optitrack) {

clock x;
state
    shutdown { ; 10000 },
    receive { ; 10000 },
    unspawned { ; 10000 };
init
    unspawned;
trans
    unspawned -> receive { sync end_spawn_publish_optitrack?; },
    receive -> shutdown { sync recv_optitrack?; assign shut_optitrack:= true; };
}

process Timer_publish_optitrack(bool &tick_publish_optitrack, urgent broadcast chan &shuttimer_publish_optitrack) {

clock x;
state
    shutdown { ; 10000 },
    start { x <= 400 };
init
    start;
trans
    start -> start { guard x==400; assign tick_publish_optitrack:= true, x:=0; },
    start -> shutdown { sync shuttimer_publish_optitrack?; };
}

process Manager_publish_optitrack(urgent broadcast chan &exe, bool &lock_publish_optitrack, bool &shut_optitrack, urgent broadcast chan &go_publish_optitrack, urgent broadcast chan &shuttimer_publish_optitrack, bool &tick_publish_optitrack) {

int count:= 0;
state
    start { ; 10000 },
    manage { ; 10000 },
    shutdown { ; 10000 };
init
    start;
trans
    start -> shutdown { guard shut_optitrack && tick_publish_optitrack; sync shuttimer_publish_optitrack!; },
    manage -> manage { guard tick_publish_optitrack; sync exe!; assign count:= count+1, tick_publish_optitrack:= false; },
    manage -> start { guard lock_publish_optitrack; sync exe!; },
    start -> manage { guard !(shut_optitrack) && tick_publish_optitrack; sync go_publish_optitrack!; assign tick_publish_optitrack:= false; };
}

process Perm_publish_optitrack(broadcast chan &end_spawn_publish_optitrack, urgent broadcast chan &go_publish_optitrack,  bool &lock_publish_optitrack, urgent broadcast chan &exe, bool &ports[nports]) {


clock x;
bool shift:= true;
state
    start_ { x<=1 },
    descr_ { x<=50 },
    recv_ { x<=50 },
    command_ { ; 10000 },
    command_2 { x<=50 },
    data_ { ; 10000 },
    data_2 { x<=100 },
    disconnect_ { x<=100 },
    pause_descr_ { ; 10000 },
    pause_recv_ { ; 10000 };
branchpoint
    descr_b,
    recv_b,
    command_b,
    data_b;
init
    start_;
trans
    pause_descr_ -> descr_ { sync go_publish_optitrack?; assign shift:= false, lock_publish_optitrack:= false, x:=0; },
    pause_recv_ -> recv_ { sync go_publish_optitrack?; assign shift:= false, lock_publish_optitrack:= false, x:=0; },
    start_ -> pause_descr_ { guard x>0; sync end_spawn_publish_optitrack!; assign update_lock_optitrack(shift, lock_publish_optitrack); },
    descr_ -> descr_b { guard x>0; },
    descr_b -> pause_descr_ { assign update_lock_optitrack(shift, lock_publish_optitrack); probability 1; },
    descr_b -> recv_ { assign x:=0; probability 1; },
    descr_b -> disconnect_ { assign x:=0; probability 1; },
    recv_ -> recv_b { guard x>0; },
    recv_b -> command_ { assign x:=0; probability 1; },
    recv_b -> data_ { assign x:=0; probability 1; },
    recv_b -> pause_recv_ { assign update_lock_optitrack(shift, lock_publish_optitrack); probability 1; },
    recv_b -> disconnect_ { assign x:=0; probability 1; },
    recv_b -> pause_descr_ { assign update_lock_optitrack(shift, lock_publish_optitrack); probability 1; },
    command_ -> command_2 { guard !ports[5] /* uses (out) the port bodies of the component optitrack */ && !ports[6]; sync exe!; assign x:=0, ports[5]:= true, ports[6]:= true; },
    command_2 -> command_b { guard x>0; },
    command_b -> pause_descr_ { assign update_lock_optitrack(shift, lock_publish_optitrack), ports[5]:= false, ports[6]:= false; probability 1; },
    command_b -> pause_recv_ { assign update_lock_optitrack(shift, lock_publish_optitrack), ports[5]:= false, ports[6]:= false; probability 1; },
    command_b -> disconnect_ { assign x:=0, ports[5]:= false, ports[6]:= false; probability 1; },
    data_ -> data_2 { guard !ports[5] /* uses (out) the port bodies of the component optitrack */ && !ports[6]; sync exe!; assign x:=0, ports[5]:= true, ports[6]:= true; },
    data_2 -> data_b { guard x>0; },
    data_b -> pause_descr_ { assign update_lock_optitrack(shift, lock_publish_optitrack), ports[5]:= false, ports[6]:= false; probability 1; },
    data_b -> pause_recv_ { assign update_lock_optitrack(shift, lock_publish_optitrack), ports[5]:= false, ports[6]:= false; probability 1; },
    disconnect_ -> pause_descr_ { guard x>0; assign update_lock_optitrack(shift, lock_publish_optitrack); };
}

process Urgency(urgent broadcast chan &exe) {

state
    wait { ; 10000 };
init
    wait;
trans
    wait -> wait { sync exe?; };
}

process client(bool &s_mikrokopter, urgent broadcast chan &recv_urg_mikrokopter, bool &s_nhfc, urgent broadcast chan &recv_urg_nhfc, bool &s_maneuver, urgent broadcast chan &recv_urg_maneuver, urgent broadcast chan &recv_mikrokopter, int[none_mikrokopter,nserv_mikrokopter-1] &req_mikrokopter, urgent broadcast chan &recv_pom, int[kill_pom,nserv_pom-1] &req_pom, urgent broadcast chan &recv_nhfc, int[none_nhfc,nserv_nhfc-1] &req_nhfc, urgent broadcast chan &recv_maneuver, int[none_maneuver,nserv_maneuver-1] &req_maneuver, urgent broadcast chan &recv_optitrack, int[kill_optitrack,nserv_optitrack-1] &req_optitrack) {

/* please adapt client according to your needs */

    clock x;
const int t := 550;
const int max:= 5;
int count:= 0;
state
    start4 { ; 10000 },
    start4_ { ; 10000 },
    ini { x<=1000 },
    finish { ; 10000 },
    wait { ; 10000 },
    wait_ { ; 10000 },
    hold { x<=t },
    start3 { ; 10000 },
    start2 { ; 10000 },
    start { ; 10000 };
init
    ini;
trans
    ini -> start { guard x==1000; },
    start -> start2 { guard s_mikrokopter; sync recv_mikrokopter!; assign req_mikrokopter:= start_mikrokopter; },
    start2 -> start3 { guard s_mikrokopter; sync recv_mikrokopter!; assign req_mikrokopter:= servo_mikrokopter; },
    start3 -> hold { guard s_nhfc; sync recv_nhfc!; assign req_nhfc:= servo_nhfc, x:=0; },
    hold -> start4_ { guard x==t; },
    start4_ -> start4 { guard s_maneuver; sync recv_maneuver!; assign req_maneuver:= set_current_state_maneuver, x:=0; },
    start4 -> wait { guard s_maneuver && sched_maneuver; sync recv_urg_maneuver!; assign req_maneuver:= take_off_maneuver, x:=0; },
    wait -> wait { guard s_maneuver && sched_maneuver && count < max; sync recv_urg_maneuver!; assign req_maneuver:= waypoint_maneuver, count:= count+1; },
    wait -> wait_ { guard s_maneuver && sched_maneuver; sync recv_urg_maneuver!; assign req_maneuver:= wait_maneuver; },
    wait_ -> finish { guard s_maneuver && sched_maneuver; sync recv_urg_maneuver!; assign req_maneuver:= take_off_maneuver; };
}


/* instantiations */

/* client */

cl:= client(s_mikrokopter, recv_urg_mikrokopter, s_nhfc, recv_urg_nhfc, s_maneuver, recv_urg_maneuver, recv_mikrokopter, req_mikrokopter, recv_pom, req_pom, recv_nhfc, req_nhfc, recv_maneuver, req_maneuver, recv_optitrack, req_optitrack);


/* mikrokopter */

CT_mikrokopter:= control_mikrokopter(s_mikrokopter, recv_mikrokopter, exe, shut_mikrokopter, recv_urg_mikrokopter, tab_mikrokopter, sched_mikrokopter, end_spawn_comm_mikrokopter, req_mikrokopter, mutex_mikrokopter);


timer_main_mikrokopter:= Timer_main_mikrokopter (tick_main_mikrokopter, shuttimer_main_mikrokopter); 

Man_main_mikrokopter:= Manager_main_mikrokopter (exe, lock_main_mikrokopter, shut_mikrokopter, go_main_mikrokopter, begin_main_mikrokopter, inter_main_mikrokopter, turn_main_mikrokopter , tab_mikrokopter, finished_main_mikrokopter, sched_mikrokopter, shuttimer_main_mikrokopter, tick_main_mikrokopter); 

	

Perm_act_main_mikrokopter:= Perm_main_mikrokopter (end_spawn_main_mikrokopter, go_main_mikrokopter,  lock_main_mikrokopter, exe, mutex_mikrokopter, ports);



start_1_mikrokopter:= start_mikrokopter_ (begin_main_mikrokopter, inter_main_mikrokopter, lock_main_mikrokopter,
 1, turn_main_mikrokopter, finished_main_mikrokopter, exe, mutex_mikrokopter, ports); 
 
start_2_mikrokopter:= start_mikrokopter_ (begin_main_mikrokopter, inter_main_mikrokopter, lock_main_mikrokopter,
 2, turn_main_mikrokopter, finished_main_mikrokopter, exe, mutex_mikrokopter, ports); 


servo_1_mikrokopter:= servo_mikrokopter_ (begin_main_mikrokopter, inter_main_mikrokopter, lock_main_mikrokopter,
 1, turn_main_mikrokopter, finished_main_mikrokopter, exe, mutex_mikrokopter, ports); 
 
servo_2_mikrokopter:= servo_mikrokopter_ (begin_main_mikrokopter, inter_main_mikrokopter, lock_main_mikrokopter,
 2, turn_main_mikrokopter, finished_main_mikrokopter, exe, mutex_mikrokopter, ports); 

	

Perm_act_comm_mikrokopter:= Perm_comm_mikrokopter (end_spawn_comm_mikrokopter, end_spawn_main_mikrokopter, exe, mutex_mikrokopter, ports);



/* pom */

CT_pom:= control_pom(recv_pom, exe, shut_pom, end_spawn_filter_pom, req_pom);


timer_io_pom:= Timer_io_pom (tick_io_pom, shuttimer_io_pom); 

Man_io_pom:= Manager_io_pom (exe, lock_io_pom, shut_pom, go_io_pom, shuttimer_io_pom, tick_io_pom); 

	

Perm_act_io_pom:= Perm_io_pom (end_spawn_io_pom, go_io_pom,  lock_io_pom, exe, mutex_pom, ports);



timer_filter_pom:= Timer_filter_pom (tick_filter_pom, shuttimer_filter_pom, end_spawn_io_pom); 

Man_filter_pom:= Manager_filter_pom (exe, lock_filter_pom, shut_pom, go_filter_pom, shuttimer_filter_pom, tick_filter_pom); 

	

Perm_act_filter_pom:= Perm_filter_pom (end_spawn_filter_pom, end_spawn_io_pom, go_filter_pom,  lock_filter_pom, exe, mutex_pom, ports);



/* nhfc */

CT_nhfc:= control_nhfc(s_nhfc, recv_nhfc, exe, shut_nhfc, recv_urg_nhfc, tab_nhfc, sched_nhfc, end_spawn_main_nhfc, req_nhfc);


timer_main_nhfc:= Timer_main_nhfc (tick_main_nhfc, shuttimer_main_nhfc); 

Man_main_nhfc:= Manager_main_nhfc (exe, lock_main_nhfc, shut_nhfc, go_main_nhfc, begin_main_nhfc, inter_main_nhfc, turn_main_nhfc , tab_nhfc, finished_main_nhfc, sched_nhfc, shuttimer_main_nhfc, tick_main_nhfc); 

	

Perm_act_main_nhfc:= Perm_main_nhfc (end_spawn_main_nhfc, go_main_nhfc,  lock_main_nhfc, exe, ports);



servo_1_nhfc:= servo_nhfc_ (begin_main_nhfc, inter_main_nhfc, lock_main_nhfc,
 1, turn_main_nhfc, finished_main_nhfc, exe, ports); 
 
servo_2_nhfc:= servo_nhfc_ (begin_main_nhfc, inter_main_nhfc, lock_main_nhfc,
 2, turn_main_nhfc, finished_main_nhfc, exe, ports); 


/* maneuver */

CT_maneuver:= control_maneuver(s_maneuver, recv_maneuver, exe, shut_maneuver, recv_urg_maneuver, tab_maneuver, sched_maneuver, end_spawn_exec_maneuver, req_maneuver, mutex_maneuver);


timer_plan_maneuver:= Timer_plan_maneuver (tick_plan_maneuver, shuttimer_plan_maneuver); 

Man_plan_maneuver:= Manager_plan_maneuver (exe, lock_plan_maneuver, shut_maneuver, begin_plan_maneuver, inter_plan_maneuver, turn_plan_maneuver , tab_maneuver, finished_plan_maneuver, sched_maneuver, shuttimer_plan_maneuver, tick_plan_maneuver); 

	

Perm_act_plan_maneuver:= Perm_plan_maneuver (end_spawn_plan_maneuver, exe, mutex_maneuver, ports);



set_current_state_1_maneuver:= set_current_state_maneuver_ (begin_plan_maneuver, inter_plan_maneuver, lock_plan_maneuver,
 1, turn_plan_maneuver, finished_plan_maneuver, exe, mutex_maneuver, ports); 
 
set_current_state_2_maneuver:= set_current_state_maneuver_ (begin_plan_maneuver, inter_plan_maneuver, lock_plan_maneuver,
 2, turn_plan_maneuver, finished_plan_maneuver, exe, mutex_maneuver, ports); 


take_off_1_maneuver:= take_off_maneuver_ (begin_plan_maneuver, inter_plan_maneuver, lock_plan_maneuver,
 1, turn_plan_maneuver, finished_plan_maneuver, exe, mutex_maneuver, ports); 
 
take_off_2_maneuver:= take_off_maneuver_ (begin_plan_maneuver, inter_plan_maneuver, lock_plan_maneuver,
 2, turn_plan_maneuver, finished_plan_maneuver, exe, mutex_maneuver, ports); 


waypoint_1_maneuver:= waypoint_maneuver_ (begin_plan_maneuver, inter_plan_maneuver, lock_plan_maneuver,
 1, turn_plan_maneuver, finished_plan_maneuver, exe, mutex_maneuver, ports); 
 
waypoint_2_maneuver:= waypoint_maneuver_ (begin_plan_maneuver, inter_plan_maneuver, lock_plan_maneuver,
 2, turn_plan_maneuver, finished_plan_maneuver, exe, mutex_maneuver, ports); 


wait_1_maneuver:= wait_maneuver_ (begin_plan_maneuver, inter_plan_maneuver, lock_plan_maneuver,
 1, turn_plan_maneuver, finished_plan_maneuver, exe, mutex_maneuver, ports); 
 
wait_2_maneuver:= wait_maneuver_ (begin_plan_maneuver, inter_plan_maneuver, lock_plan_maneuver,
 2, turn_plan_maneuver, finished_plan_maneuver, exe, mutex_maneuver, ports); 


timer_exec_maneuver:= Timer_exec_maneuver (tick_exec_maneuver, shuttimer_exec_maneuver, end_spawn_plan_maneuver); 

Man_exec_maneuver:= Manager_exec_maneuver (exe, lock_exec_maneuver, shut_maneuver, go_exec_maneuver, shuttimer_exec_maneuver, tick_exec_maneuver); 

	

Perm_act_exec_maneuver:= Perm_exec_maneuver (end_spawn_exec_maneuver, end_spawn_plan_maneuver, go_exec_maneuver,  lock_exec_maneuver, exe, mutex_maneuver, ports);



/* optitrack */

CT_optitrack:= control_optitrack(recv_optitrack, exe, shut_optitrack, end_spawn_publish_optitrack, req_optitrack);


timer_publish_optitrack:= Timer_publish_optitrack (tick_publish_optitrack, shuttimer_publish_optitrack); 

Man_publish_optitrack:= Manager_publish_optitrack (exe, lock_publish_optitrack, shut_optitrack, go_publish_optitrack, shuttimer_publish_optitrack, tick_publish_optitrack); 

	

Perm_act_publish_optitrack:= Perm_publish_optitrack (end_spawn_publish_optitrack, go_publish_optitrack,  lock_publish_optitrack, exe, ports);



urg:= Urgency(exe);


system cl, urg, CT_mikrokopter, timer_main_mikrokopter, Man_main_mikrokopter, Perm_act_main_mikrokopter, start_1_mikrokopter, start_2_mikrokopter, servo_1_mikrokopter, servo_2_mikrokopter, Perm_act_comm_mikrokopter, CT_pom, timer_io_pom, Man_io_pom, Perm_act_io_pom, timer_filter_pom, Man_filter_pom, Perm_act_filter_pom, CT_nhfc, timer_main_nhfc, Man_main_nhfc, Perm_act_main_nhfc, servo_1_nhfc, servo_2_nhfc, CT_maneuver, timer_plan_maneuver, Man_plan_maneuver, Perm_act_plan_maneuver, set_current_state_1_maneuver, set_current_state_2_maneuver, take_off_1_maneuver, take_off_2_maneuver, waypoint_1_maneuver, waypoint_2_maneuver, wait_1_maneuver, wait_2_maneuver, timer_exec_maneuver, Man_exec_maneuver, Perm_act_exec_maneuver, CT_optitrack, timer_publish_optitrack, Man_publish_optitrack, Perm_act_publish_optitrack;
